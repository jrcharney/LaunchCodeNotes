# 8. Interfaces and Polymorphism

[toc]

---

## 8.1. Introduction

### 8.1.1. Polymorphism

## 8.2. Interfaces

### 8.2.1. Creating an Interface

#### 8.2.1.1. Method Signatures

#### 8.2.1.2. Static Methods

#### 8.2.1.3. Default Methods

### 8.2.2. Implementing an Interface

### 8.2.3. Benefits of Using Interfaces

### 8.2.4. Check Your Understanding :white_check_mark:

## 8.3. Interfaces and Abstract Classes

### 8.3.1. Check Your Understanding :white_check_mark:

## 8.4. Interfaces In The Wild

### 8.4.1. `Comparable<T>`

### 8.4.2. `Comparator<T>`

### 8.4.3. `Iterable<T>`

### 8.4.4. `List<E>`

### 8.4.5. `Map<K, V>`

### 8.4.6. Check Your Understanding :white_check_mark:

## 8.5. Unit Testing and Interfaces

### 8.5.1. Check Your Understanding :white_check_mark:

## 8.6. Exercises: Interfaces and Polymorphism :runner:

### 8.6.1. Getting Started

### 8.6.2. Sorting Flavors by Name

#### 8.6.2.1. Create a Sorting Class

#### 8.6.2.2. Sorting the `flavors` `ArrayList`

### 8.6.3. Sorting Cones by Cost

#### 8.6.3.1. Troubleshooting :hammer_and_wrench:

### 8.6.4. Bonus Exercises :rocket:

### 8.6.5. Next Steps

## 8.7. Studio: Spinning the Discs :studio_microphone:

### 8.7.1. Getting Ready

### 8.7.2. Disc Project Overview

### 8.7.3. Consider Generic Behaviors

### 8.7.4. Consider Class-Specific Behavior and Data

### 8.7.5. Code the Interface

### 8.7.6. Code the Abstract Class

### 8.7.7. Complete the Disc Classes

### 8.7.8. Add Method Calls to `main`

### 8.7.9. Bonus Missions: Other Discs & Disks?

---

#Java