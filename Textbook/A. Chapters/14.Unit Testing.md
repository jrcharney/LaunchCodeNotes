# 14. Unit Testing

[toc]

---

## 14.1. Why Test Your Code?

Checking your code is part of the development process. Developers rarely write code without verifiying it. You are used to debugging programs as you write them. In fact, we devoted an entire chapter to debugging back in [chapter 6](06.Errors%20Debugging.md).

Your development process probably looks something like this.

```mermaid
stateDiagram
	%%title "Develoment Process"
	
	%% states
	Write
	Run
	Fix
	
	%% transitions
	[*] --> Write
	Write --> Run
	Run --> Fix
	Fix --> Write
	Fix --> [*]

	note left of Run
		1. Write Code
		2. Run program
		3. Notice errors and investigate
		4. Repeat these steps until there are no more errors
	end note
```

But there is a better way to test your code using *automated* tests. Automated tests actively test your code and to remove the burden of manual testing. There are many types of automated tests. This chapter focuses on **unit testing**, which tests the smallest components (or *units*) of code. Theyse are typically individual functions.

Before we dive into the *how* of unit testing, let's discuss the *why*.

### 14.1.1. Know Your Code *Really* Works

Manual testing can eventually lead you to a complete, error-free program. Unit testing provides a better alternative.

Does this sound familiar:

>  *You write a program and manually test it. Thinking it is complete, you turn it in only to find that it has a bug or use case that you didn't consider.*

The unit testing process helps avoid this by starting with a list of specific, clearly stated behaviors, that the program should satisify. The behaviors are then converted into automated test that demonstrate program behavior and provide a framework for writing code that *really* works.

### 14.1.2. Find Regressions

How about this situation:

> *You write feature #1 for a program. You move on to feature #2. After finishing feature #2, you realize that your changes broke feature #1.*

Frustrating, right? Espeically with larger programs, adding new features often cause unexpected problems in other part of the code, potentially breaking the entire progra. The introduction of such a bug is known as **regression**.

If you have a collection of tests that can run quickly and consistently, you will know *right away* when a regression appears in your program. This allows you to identify and fix your program more quickly.

### 14.1.3. Tests as Documentation

One of the most poerful aspects of unit testing is that it allows us to clearly define program expectations. ==A good collection of unit test can function as a set of *statements* about *how* the program should behave.== You and others can read the tests and quickly get an idea of the specifics and program behaviors.

> **Example**: Your coworker gives you a function that validates phone numbers, but doesn't provide much detail. Does it handle country codes? Does it require an area code? Does it allow parethesis around area codes? These details would be easily understood if the function had a collection of unit tests that described its behavior.

==Code with a good, descriptive set of unit tests is sometimes called **self-documenting code**.==

Remembering wat your code does and why you structured it a certain way is easy for small programs. However, as the number of your projects increa, and their size grows, the need for documentation becomes critical.

> :tv: **PSA**: I would recommend using [JSDoc](https://jsdoc.app/) notation for documentation in comments.

Documentation can be in the form of code comments or external text documents. These can be helpful, but have one mayor drawback: They can get out of date very quickly. Out-dated, incorrect documentation is very frustrating for a user.

Properly desgined unit tests are runnable documentation for your projects. Beacause unit tests are runnable code that declares and verifies features, they can NEVER get out of sync with the updated code. If a feature is added or removed, the tests must be updated in order to make them pass.

## 14.2. Hello, Jasmine!

> :white_flower: **HEY!** I've added a [Jasmine Reference](../../My%20LC%20Notes/Jasmine%20Reference/index.md) to my notes! Check it out!

In order to unit test our code, we need to use a module. Such a module is called a **unit-testing framework**, **test runner**, or **test harness**, and there are [many to choose from](https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks#JavaScript).

We will use [**Jasmine**](https://jasmine.github.io/).

### 14.2.1. Using Jasmine

Jasmine is an NPM module that can be installed and used in a manner similar to `readline-sync`. We'll learn how to install it later.

In this chapter, we ill continue to use Repl.it which automatically installs NPM modules when it runs a program that contains a `require` statement.

> ðŸ§© **Try it!** Run some [tests for the `reverse` function](https://repl.it/@launchcode/reverse-Function-With-Tests). This is the same `reverse` function that we we wrote previously in section 10.8.
>
> Don't worry about understanding the code at this point, just hit "Run" to execute the test. How many tests are there? How many passed? How many failed?

A project using Jasmine has several components. Here's the project structure.

```
|- ðŸ“„ index.js				// (3)
|- ðŸ“ spec
|  |- ðŸ“„ reverse.spec.js	// (2)
|- ðŸ“„ package-lock.json
|- ðŸ“„ reverse.js			// (1)
```

There are three important files:

1. **`reverse.js`** contains the `reverse` function, which must be exported for use to other files.
2. **`spec/reverse.spec.js`** contains the test for `reverse`.
3. **`index.js`** contains the Jasmine code needed to run the tests. This is the file that executes when you hit "Run" in Repl.it

> :warning: **WARNING!** Jasmine can be set up and used in many different ways. If you are looking for answers on the internet, on sites like [Stack Overflow](https://stackoverflow.com/questions/tagged/jasmine) or in the [Jasmine documentation](https://jasmine.github.io/pages/docs_home.html), you will see widely varying usages of Jasmine that are irrelevant. Rely on this book as your main reference, and you'll be fine.

### 14.2.2. Hello, Jasmine!

Let's build a "Hello, World!" Jasmine project. Open and fork [this Repl.it project](https://repl.it/@launchcode/Hello-Jasmine-Starter-Code).

#### 14.2.2.1. `index.js`

The main file.

```js
var Jasmine = require('jasmine');
var jasmine = new Jasmine();

jasmine.loadConfig({
  spec_dir: 'spec',
  spec_files: [
    "**/*[sS]pec.js"
  ],
});

jasmine.execute();
```

There are three main components of this program:

1. Lines 1 and 2 import the Jasmine module and create the new Jasmine object, `jasmine`. This object is responsible for finding and executing our tests.
2. Lines 4 through 9 configure Jasmine to look for the tests in the `spec` directory of our project. Any file in this directory of the form `filename.spec.js` will be assumed to contain tests, and will be executed by Jasmine.
3. Line 11 triggers Jasmine to find and execute the test.

> ðŸ§© **Try it!**:  Hit "Run" on the project. Two things will happen:
>
> 1. Repl.it will install Jasmine.
> 2. Jasmine will search for test. Because the `spec` directory doesn't exist yet, there is no `filename.spec.js` file to look for tests to execute.

Let's add some code to test.

#### 14.2.2.2. `hello.js`

Create a new file by clicking on the icon that looks similar to this emoji: ðŸ“„

Name the new file `hello.js` then add the following code:

```js
function hello(name) {
   if (name === undefined)
      name = "World";

   return "Hello, " + name + "!";
}
```

The `hello` function takes a single argument, representing a person's name and returns a string greeting that person. If the function is called without an argument, the function returns `"Hello, World!"`.

> :information_source: **NOTE**: We could revise that code to something more modern and shorter.
>
> ```js
> function hello(name = "World") {
>    return `Hello, ${name}!`;
> }
> ```

To use the function outside of `hello.js`, we must export it and add the following line at the bottom:

```js
module.exports = hello;
```

#### 14.2.2.3. `spec/hello.spec.js`

Now that we have a function to test, let's write some test code.

Add a folder (using the icon that looks similar to this emoji ðŸ“ ) and name it `spec`.

Inside the `spec` folder, add a file called `hello.spec.js`.

> **TIP**: If is convetional to put test fo `fileName.js` into `spec/fileName.spec.js` to make it easy to find tests associated with a given file.

Your file tree should look something like this:

```
|- ðŸ“„ index.js
|- ðŸ“ spec
|  |- ðŸ“„ hello.spec.js
|- ðŸ“„ package-lock.json
|- ðŸ“„ hello.js
```

At the top of the `hello.spec.js` file, import your function from `hello.js` along with the `assert` module which is part of Node.js.

```js
const hello = require('../hello.js');
const assert = require('assert');
```

Below that, call the function `describe`, passing in the name of the function we want to test along with an empty anonymous function. **`describe`** is a Jasmine function that is used to group related tests. Related tests are placed within an anonymous function that it receives.

```js
describe("hello", function(){
    
});
```

#### 14.2.2.4. Specifications and Assertions

There are two test cases we want to test:

1. The function is called with a string argument. In this case, a custom greeting should be retured.
2. The function is called with no argument. In this case, the general greeting should be returned.

Within `describe`'s function argument, place a test for case 1:

```js
it("should return custom message when name is specified", function(){
    assert.strictEqual(hello("Jasmine"), "Hello, Jasmine!");
});
```

The **`it`** function is part of the Jasmine framework as well. Calling `it` creates a **specification**, or **spec**, which is a description of expected behavior.

The first argument in `it` is a string describing the expected behavior. This string serves to document the test and also is used for reporting test results. Your expectation strings will usually begin with `"should"`, followed by an expected action.

The second argument in `it` is yet another anonymous function. This function contains the test code itself, which takes the form of an assertion. An **assertion** is a declaration of expected behavior *in code*. Let's examine the contents of the anonymous function:

```js
assert.strictEqual(hello("Jasmine"), "Hello, Jasmine!");
```

Calling `assert.strictEqual` with two arguments declares that we expect the two arguments to be (strictly) equal. As you get started with unit testing, nearly *all* of your tests will take this form. The first argment of `assert.strictEqual` is a call to the function `hello`. The second argument is the expected output from that function call.

If the two arguments are indeed equal, the test will pass. Otherwise, the test will fail. In this case, we are declaring that `hello("Jasmine")` should return the value `"Hello, Jasmine!"`.

> :information_source: **NOTE**: Jasmine also has a `.equal` comparison which tests for *loose* equality. It should be pretty obvious from when we spoke of the difference between `==` and `===` operator what the `.equal` and `.strictEqual` functions do in Jasmine.

The test file should now look like this:

```js
const hello = require('../hello.js');
const assert = require('assert');

describe("hello world test", function(){
    it("should return custom message when name is specified", function(){
    	assert.strictEqual(hello("Jasmine"), "Hello, Jasmine!");
	});
    
});
```

#### 14.2.2.5. Test Reporting

This is a fully-functioning test file. Hit "Run" to see for yourself. If all is good, the output wil look like this:

```
Randomized with seed 00798
Started
.


1 spec, 0 failures
Finished in 0.016 seconds
Randomized with seed 00798 (jasmine --random=true --seed=00798)
```

The most important line in the output is line 6:

```
1 spec, 0 failures
```

It tells us that Jasmine found 1 test specification, and that 0 of the specs failed. In other words, *our test passed!*.

Line 3 also contains useful infomration. It contains one dot (`.`) for each successful test, and a `F` for each failed test. As our test suite grows, this becomes a nice visual indicator of the status of our tests.

Let's see what a test failure looks like. Go back to `hello.js` and remove the exclaimation point (`"!"`) from the return statement so that it looks like this:

```js
return "Hello, " + name;
```

Run the tests again. This time, the output looks quite different:

```
Randomized with seed 98738
Started
F

Failures:
1) hello world test should return a custom message when name is specified
Message:
   AssertionError [ERR_ASSERTION]: Input A expected to strictly equal input B:
   + expected - actual

   - 'Hello, Jasmine'
   + 'Hello, Jasmine!'
Stack:
   error properties: Object({ generatedMessage: true, code: 'ERR_ASSERTION', actual: 'Hello, Jasmine', expected: 'Hello, Jasmine!', operator: 'strictEqual' })
      at <Jasmine>
      at UserContext.<anonymous> (/home/runner/spec/reverse.spec.js:23:14)
      at <Jasmine>
      at runCallback (timers.js:705:18)
      at tryOnImmediate (timers.js:676:5)
      at processImmediate (timers.js:658:5)

1 specs, 1 failure
Finished in 0.021 seconds
```

We intentionally made a test fail. The failing test appear in the `Failures:` section on line 5. This  describes exactly what went wrong. The test expected the value `'Hello, Jasmine!'` but received `'Hello, Jasmine'` (without exclaimation point). Notice the failure description is the result of joining the two string arugments from `describe` and `it`. This is why we intentionally define those string the way we did.

The `Stack:` section on line 13 is mostly ignored for now. 

Line 22 has a key statistic showing how many tests, called specs, were run and how many failed. 

```
1 spec, 1 failure
```

Restore `hello.js` back to the way it was and run the test again to mak sure that it works.

Let's add a final spec to test our other cases.

```js
it("should return a general greeting when name is not specified", function(){
     assert.strictEqual(hello(), "Hello, World!");
});
```

This spec declares that calling `hello()` should return `"Hello, World!"`. Run the tests again and you will see the outout:

```
Randomized with seed 81081
Started
..


2 specs, 0 failures
Finished in 0.025 seconds
Randomized with seed 81081 (jasmine --random=true --seed=81081)
```

Awesome! You just created your first program with a full test suite. Compare yours to [how LaunchCode did theirs](https://repl.it/@launchcode/Hello-Jasmine) for reference.

There are a lot of detail in the setup of these test, so take a few minutes to look over the code and describe to yourself what each component is doing.

> :information_source: **NOTE**: There are many ways to structure test specficiations. If you look at the official Jasmine documentation, you see specs with differnt code in place of `assert.stricEqual`.
>
> The book author chose to use `assert.strickEqual` because its syntax is more similar to common testing frameworks in other languages like Java and C#. Learning to use `assert.strictEqual` will make it easier for you to transition to ne of those frameworks later in class.

### 14.2.3. Check Your Understanding :white_check_mark:

> :question: **Question**: Examine the function below, which checks if two strings match:
>
> ```js
> function doStringsMatch(string1, string2){
>    if (string1 === string2) {
>       return 'Strings match!';
>    } else {
>       return 'No match!';
>    }
> }
> ```
>
> Which of the following tests checkes if the function properly handles *case-senstive* answers.
>
> a. `assert.strictEqual(doStringsMatch('Flower', 'Flower'), 'Strings match!');`
> b. `assert.strictEqual(doStringsMatch('Flower', 'flower'), 'No match!');`
> c. `assert.strictEqual(doStringsMatch('Flower', 'plant'), 'No match!');`
> d. `assert.strictEqual(doStringsMatch('Flower', ''), 'No match!');`
>
> :exclamation: **Answer**:

## 14.3. Unit Testing in Action

Testing is a bit of an art: there are no hard and fast rules about how to go about writing good tests. That said, there are some general principles that you should follow.

In this section, we will explore some of these. In particular, we focus on identifying good **test cases** by working through a specific example. ==A test case is a single situation that is being tested.== 

### 14.3.1. What to Test

When writing tests for your code, what should you test? You can't test *every* possible situation or input. But you also don't want to leave out important cases. A function or program that isn't well-tested might have bugs luring beneath the surface.

> :information_source: **Note**: Since we are focusing on *unit* testing, in this chapter we will generally use the term "unit" to refer to the function of program under consideration.

Regardless of the situation, there are three tyes of test cases that you should consider:

1. **Positive test** cases verify expected behavior with valid data.
2. **Negative test** cases verify expected behavior with invalid data.
3. An **edge case** is a subset of postive tests, which checks the extreme edges of valid values.

> **Example**: Imagine a function named `setTemperature` that accepts a number between `50` and `100`.
>
> 1. Positive test values: `56`, `75`, `80`
> 2. Negative test values: `-1`, `101`, `"70"`
> 3. Edge case values: `50`, `100`

Considering postive, negative, and edge tests will go a long way toward heling you create well-tested code.

### 14.3.2. Setting Up

Let's see these actions by writing tests for our `isPalindrome` function. ([Link](https://repl.it/@launchcode/isPalindrome))

```js
function reverse(str) {
   return str.split('').reverse().join('');
}

function isPalindrome(str) {
   return reverse(str) === str;
}
```

Code along with LaunchCode by forking [their Repl.it starter code project](https://repl.it/@launchcode/isPalindrome-With-Tests-Starter). This version includes the above code in `palindrome.js` and the Jasmine test runner code in `index.js`.

Note: The orignainl code's `console.log` statements were removed and exported the `isPalindrome` function:

```js
module.exports = isPalindrome;
```

> **Tip**: When crating a unit-tested projec *always* start by copying the Jasmine test runner code into `index.js` and putting the code you want to test in an appropriately named `.js` file.

==You have become used to testing your code by running it and printing output with `console.log`. When writing unit-testing code, we no longer need to take this approach.==

> **Tip**: If you find yourelf tempted to add a `console.log` statement to your code, write a unit test instead! You would most likely remove that `console.log` after getting your code to work, while the test will remain for you and other developers to use in the future.

Finally, create the `spec` directory and add a spec file, `palindrome.spec.js`. This file should include imports and `describe` block:

```js
const isPalindrome = require('../palindrome.js');
const assert = require('assert');

describe("isPalindrome", function(){

   // TODO - write some tests!

});
```

OK! Let's write some tests!

### 14.3.3. Positive and Negative Test Cases

We'll start with postive and negative tests.

#### 14.3.3.1. Positive Test Cases

For `isPalindrome`, some postive teests have inputs:

* `"a"`
* `"aaaa"`
* `"aba"`
* `"racecar"`

Calling `isPalindrome` with these inputs should return `true` in each case. Notice that these tests are as simple as possible. (K.I.S.S.! :kiss:) Keep test input simple, while still covering your desired test cases, will make it easier to fix a bug in the event that a unit test fails.

Let's add tests for these inputs to `spec/palindrome.spec.js`

```js
const isPalindrome = require('../palindrome.js');
const assert = require('assert');

describe("isPalindrome", function(){

   it("should return true for a single letter", function(){
      assert.strictEqual(isPalindrome("a"), true);
   });

   it("should return true for a single letter repeated", function(){
      assert.strictEqual(isPalindrome("aaa"), true);
   });

   it("should return true for a simple palindrome", function(){
      assert.strictEqual(isPalindrome("aba"), true);
   });

   it("should return true for a longer palindrome", function(){
      assert.strictEqual(isPalindrome("racecar"), true);
   });

});
```

Note the clear test case description (for example, `"should return true for a single letter repeated"`), which will help us easily, identify the expected behavior of our code later.

After adding the positive tests to your file, run them to make sure they all pass.

#### 14.3.3.2. Negative Test Cases

For `isPalindrome`, some negative tests have inputs:

* `"ab"`
* `"launchcode"`
* `"abA"`
* `"so many dynamos"`

Calling `isPalindrome` with those inputs should return `false` in each case. The last two of these negative tests deserve a bit more discussion.

When writing our `isPalindrome` function initially, we made two important decisions:

* Case should be considered ("case-sensitive"), and 
* White space should be considered.

The defintion of a palindrome differs sometimes on these two matters, so it's important to test them.

Testing with input `"abA"` ensures that case is considered, since the lowercase version of this string, `"aba"`, *is* a palindrome.

Testing with `"so many dynamos"` ensures that the whitespace is considered, since the version of this string with whitespace removed, `"somanydynamos"`, *is* a palindrome.

> :information_source: **NOTE**: It's important to isolate your test cases. For example, `"So Many Dynamos"` is a poor choice of input for a negative test, since it contains *two* characteristics that are being tested for--case *and* whitespace. If a test with this input failed, it would NOT be clear why it failed.

Including specific tests that demostrate how *our* `isPalindrome` function behaves in these situations helps make our code *self-documenting*. Someone can read our code and easily see that we *do* consider case and whitespace.

Let's add some tests for these negative cases. Add these with the `describe` call.

```js
it("should return false for a longer non-palindrome", function(){
   assert.strictEqual(isPalindrome("launchcode"), false);
});

it("should return false for a simple non-palindrome", function(){
   assert.strictEqual(isPalindrome("ab"), false);
});

it("should be case-sensitive", function(){
   assert.strictEqual(isPalindrome("abA"), false);
});

it("should consider whitespace", function(){
   assert.strictEqual(isPalindrome("so many dynamos"), false);
});
```

Now run the tests to make sure they pass. Your code nwo includes a set of tests that considers a wide variatety of postive and negative cases.

### 14.3.4. Edge Cases

Recall our defintion of **edge case**:

> ==*An edge case is a test case that provides input at the extreme dge of what the unit should be able to handle.*==

Edge cases can look very different for different units of code. Most of the examples we provide above dealt with numerical edge cases. However, edge cases can aslo be non-numeric.

In the case of `isPalindrome`, the most obvious edge case would be that of the empty string, `""`. This is the smalles possible string that we can use when calling `isPalindrome`. Not only is it the smallest, but it is essentially *different* from the nex longest string, `"a"` -- one has characters and one doesn't.

Should the empty string be considered a palindrome? That decision is up to us, the programmer, and there's no right or wrong answer. In our case, we have decided to take a very literal defintion of the term "palindrome" by considering case and whitespace. In other words, or defintion says that a string is a palindrome exactly when it equals its reverse. Since the reverse of `""` is also `""`, it makes sense to consider the empty string as a palindrome.

Let's add this test case to our spec:

```js
it("should consider the empty string a palindrome", function(){
   assert.strictEqual(isPalindrome(""), true);
});
```

Now run the test, which should all pass.

You might want to think that another edge caise is that the longest possible palindrome. Such a palindrome would be the longest possible string in JavaScript. This case is not worth considering for a couple of reasons:

* The length of the longest string [can vary across different JavaScript implementations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length#Description). (YMMV :fuelpump: )
* As of JavaScript specification ES2016 (a.k.a. ES7), states that the maximum allowed lenght of a string should be $2^{53}-1$ characters. This is a lot of characters! ðŸ¥œ It's alos unrealistic to expect that our function will ever be given such a string. (This is the part where some guy who thinks they're a hacker says "CHALLENGE ACCEPTED!" fails or waits forever!)

> :information_source: **NOTE**: It might be wise to keep positive, negative, and edge cases grouped together:
>
> ```js
> describe("functionMcFunctonFace",function(){
>     // Positve Tests
>     it("should work",function(){
>         assert.strictEqual(isWorking("testoMcTesto"),true);
>     });
>     // other positive tests here
>     
>     // Negative Tests
>     it("should work",function(){
>         assert.strictEqual(isWorking("failyMacFailFail"),fail)
>     });
>     // other negative tests here
>     
>     // Edge Tests
>     it("should consider empty string",function(){
>         assert.___(isWorking(""),true)
>     });
>     // other edge cases here
> });
> ```

### 14.3.5. Toward a Better Testing Workflow

In this case, we had a well-written function to write tests for, so it was straightforward to create tests that pass. Most situations will not be this simple. Your tests will often uncover bugs, forcing you to go back and update your code. That's OK because it's precisely what tests are for!

The workflow in this situation is:

1. Write code
2. Write Tests
3. Fix any bugs found while testing

The rest of the chapter focusts on a programming technique that allows you to completely eliminate the third step by reversing the order of the first two;

1. Write tests
2. Write code

As you will soon learn, writing yout tests *before* the code is a great way to enhance your programming efficiency and quality.

Let's revew that with this diagra below.

> ðŸ§œâ€â™€ï¸ **MERMAID**: I would have hoped this state diagram would have been a little more elegant.

```mermaid
stateDiagram
state Old_and_Busted {
	state "1. Write Code" as Code
	state "2. Write Tests" as Write
	state "3. Fix bugs" as Fix
	
	[*] --> Code
	Code --> Write
	Write --> Fix
	Fix --> Code
	Fix --> [*]
}
```

```mermaid
stateDiagram
state New_Hotness {
	state "1. Write Tests" as Tests
    state "2. Write Codes" as Codes
	
	[*] --> Tests
	Tests --> Codes
	Codes --> Tests
	Codes --> [*]
}
```

> :tv: **FYI**: **ES-*wha?***
>
> You've seen people describe the difference in javascript specifications by year number (ES2016) or by version number (ES7). Let's clear this up really quick.
>
> | Year | Name   | Number |
> | ---- | ------ | ------ |
> | 2015 | ES2015 | ES6    |
> | 2016 | ES2016 | ES7    |
> | 2017 | ES2017 | ES8    |
> | 2018 | ES2018 | ES9    |
> | 2019 | ES2019 | ES10   |
> | 2020 | ES2020 | ES11?  |
>
> > :reminder_ribbon: **TODO**: Add links to the ECMA specifications later.

### 14.3.6. Check Your Understanding :white_check_mark:

Lets' assume we've updated `isPalindrome` to be case-insenstive (e.g. `isPalindrom('Radar')` returns `true`).

> :question: **Question**: Which of the following is an example of a *positive* test case for checking if `isPalindrome` is case-insensitive?
> a. `aa`
> b. `aBa`
> c. `Mom`
> d. `Taco Cat` 
> e. `AbAb`
>
> :exclamation: **Answer**: a, b, and c.

> :question: **Question**: Which of the *negative* test cases listed above are no longer valid for our case-insensitive `isPalindrome`?
> a. `ab`
> b. `launchcode`
> c. `abA`
> d. `so many dynamos`
>
> :exclamation: **Answer**:

## 14.4. Test-Driven Development (TDD)

Now that we know more about unit testing, we are going to learn a new way of using it. So far we've written tests to verify functionality of *existing* code. Next we are going to use test to verify the functionality of code that does not already exist.

As the name sounds, ==**Test-driven development** (**TDD**) is a software development process where the unit tests are written first.== However, that's not the whole story. ==Writing the tests first and intentionally thinking more about code design leads to better code.==  The name comes from the idea of the tests *driving* the development process.

Before we can start using TDD, we need a list of discrete features that can be turned into unit tests. This will help keep our tests focused on specific functionality which should lead to cod that is easy to read. Along the way, we will build confidence as we add features.

> :information_source: **NOTE**: TDD is a process that some organizations choose to use. Using the TDD process is not required when unit testing.

### 14.4.1. Test/Code Cycle

> :reminder_ribbon: **TODO**: :detective: **EDIT!** There were plenty of errors in this section of the book. I may have picked some of them up in my notes here. This section needs to be reviewed later.

With TDD you start the unit test first. As with any unit test, the test should describe a clearly described behavior that can be tested.

> **Example**: Example test case for a data parsing project.
>
> * Take in a string of numbers

Because the test is for a feature that does not exist yet, we need to think about how the feature will be implemented. This is the time to ask questions like:

*  "Should we add a new parameter?"
* "What about an entirely new function?"
* "What will the function return?"

> **Example**: How could we implement our test case? (Remember, we aren't writing the code yet, only think about the design.)
>
> * A function named `parseData`
> * `parseData` will 
>   * have a `data` parameter that will be a string of data
>   * have a `delimiter` parameter that will be used to split the string into an array
>   * return an array
> * `parseData` will be defined in a module.
>
> > :coffee: **JSDoc**: Why not document this in comments using JSDoc?
> >
> > ```js
> > /* @file parse-numbers.js
> >  * @module parse-numbers
> >  */
> > 
> > /* @func parseData
> >  * @desc Take a string of numbers delimited by a character and return an array
> >  * @param {string} text - String of data
> >  * @param {string} delimiter - String that will be used to split string into an array
> >  * @return {array}
> >  */
> > function parseData(text,delimiter){
> >     /* our code */
> > }
> > ```

Next, write the unit test as if the parameter of function you imagined already exists. This may seem odd, but considering how the new code will be used help find bugs and flaws earlier. We also have to use test utilities such as `assert.strictEqual` to clearly demonstrate that the proposed new code function properly.

> **Example**: This is where the ideas are typed out into a test. In this example, the test references a module and a function that have not been created yet. The code follows the plan we came up with earlier. Most importantly, there is a `assert.strictEqual` that verifies that an array is returned.
>
> ```js
> const assert = require('assert');
> const parse = require('../parse-numbers');
> 
> describe("parse numbers", function(){
> 
>    it("returns array when passed comma separated list of numbers", function(){
>       let items = parse("5,8,0,17,6,4,9,3", ",");
>       assert.strictEqual(Array.isArray(items), true);
>    });
> 
> });
> ```

Now run the test! The test should fail. If it doesn't, your code will not compile because you have referenced code that des not exist yet.

Finally, write code that passes the new test. In the earlier chapters, this is where you started, but ==with TDD, writing new code is the *last* step.==

> **Example**: To make the above test pass, a file would be crated that exports a `parseData` function with the logic that satisfies the expected result.
>
> ```js
> function parseData(text,delimiter){
>     return text.split(delimiter);
> }
> 
> module.exports = parseData;
> ```

Coding this way build confidence in your work. No mater how large your code base may get, you know that each part has a test to validate its functionality.

> **Example**: Now that we have one passing test for our data parser project, we could confidently move on to writing tests and code for the remaining features.

### 14.4.2. Red, Green, Refactor

While adding new features and making our code work is the main goal, we also want to write readable, efficient code that we feel good about. The **red, green, refactor mantra** describes the process of writing tests, seeing them pass, then making the code better. As the name suggests, the cycle consisists of three steps:

1. <span style="color:red;">**Red**</span> refers to test results that fail. Write a failing test.
2. <span style="color:green;">**Green**</span> refers to test results that pass. Make it pass by implementing code.
3. **Refactor**. Make the code better.

```mermaid
stateDiagram
	Red --> Green
	Green --> Refactor
	Refactor --> Red
```

> :reminder_ribbon: **TODO**:  Oh mermaid! Can't you draw that right?!

**Refactoring** code means to keep the same overall features, but change how those features are implemented. Since we have a test to verify our code, we can change the code with confidence, knowing that any regression will be immediately identified by the tests.

Here are a few examples of refactoring:

* Using different data structures.
* Reducing the number of times needed to loop through an array.
* Moving duplicate logic into a function so that it can be reused.

The refactor is also done in a TDD process:

1. Decide on what is the improved way to implement the feature, then change the unit test to use this new idea.
2. See the test fail, then implement the refactor idea.
3. See the test pass with the refactored design.

## 14.5. TDD in Action

> :reminder_ribbon: **TODO**: Post this part later. Right now I need to catch up on some stuff.

### 14.5.1. Requirements

### 14.5.2. Requirement #1

#### 14.5.2.1. Code Red

#### 14.5.2.2. Go Green!

#### 14.5.2.3. Refactor If Needed

### 14.5.3. Requirement #2

### 14.5.4. Requirement #3

### 14.5.5. Requirement #4

### 14.5.6. Requirement #5

### 14.5.7. Requirement #6

### 14.5.8. Use TDD to Add These Features

## 14.6. Exercises: Unit Testing :runner:

> :x: **CENSORED**

### 14.6.1. Automatic Testing to Find Errors

### 14.6.2. Try One on Your Own

### 14.6.3. Bonus Mission :rocket:

## 14.7. Studio: Unit Testing :studio_microphone:

> :x: **CENSORED**

### 14.7.1. Source Code

### 14.7.2. Write the First Test

### 14.7.3. Write Code to Pass the First Test

### 14.7.4. Write the Next Two Tests

### 14.7.5. Write Code to Pass the New Tests

### 14.7.6. Hmmm, Tricky

### 14.7.7. More Tests and Code Snippets

### 14.7.8. New Condition

### 14.7.9. Bonus Missions :rocket:

#### 14.7.9.1. DRYing the Code

#### 14.7.9.2. What If We Already Have Code?



:checkered_flag: **OH THANK HEAVENS! IT'S OVER!** This chapter was such a long thing to do and I don't think I did a couple of things I should have. We'll get back to them later. Right now, let's knock out this next chapter on [Scope](15.Scope.md).

---

#LaunchCode

